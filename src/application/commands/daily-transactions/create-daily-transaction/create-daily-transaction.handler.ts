import { HttpStatus, Injectable, NotFoundException } from '@nestjs/common';
import { CommandHandler, ICommandHandler } from '@nestjs/cqrs';
import { CreateDailyTransactionCommand } from './create-daily-transaction.command';
import { DailyTransactionRepository } from '@infrastructure/repositories/daily-transaction.repository';
import { PlanItemRepository } from '@infrastructure/repositories/planItem.repository';
import { PlanRepository } from '@infrastructure/repositories/plan.repository';
import { DailySummaryRepository } from '@infrastructure/repositories/daily-summary.repository';
import { DailyTransactionResponseDto } from '@shared/dtos/daily-transactions';
import { buildHttpExceptionResponse } from '@shared/utils';
import { PlanCalculationService } from '@shared/services/plan-calculation.service';
import { DefaultTransactionAutoGeneratorService } from '@shared/services/default-transaction-auto-generator.service';
import {
  EXCLUDE_TYPE,
  PlanItemType,
} from '@domain/entities/planItem/planItem.enum';
import { TransactionType } from '@domain/entities/daily-transaction/daily-transaction.entity';
import { DailyStatus } from '@domain/entities/daily-summary/daily-summary.entity';

@CommandHandler(CreateDailyTransactionCommand)
@Injectable()
export class CreateDailyTransactionHandler
  implements
    ICommandHandler<CreateDailyTransactionCommand, DailyTransactionResponseDto>
{
  constructor(
    private readonly dailyTransactionRepository: DailyTransactionRepository,
    private readonly planItemRepository: PlanItemRepository,
    private readonly planRepository: PlanRepository,
    private readonly dailySummaryRepository: DailySummaryRepository,
    private readonly planCalculationService: PlanCalculationService,
    private readonly defaultTransactionAutoGenerator: DefaultTransactionAutoGeneratorService,
  ) {}

  async execute(
    command: CreateDailyTransactionCommand,
  ): Promise<DailyTransactionResponseDto> {
    const { planId, planItemId, dto } = command;

    const plan = await this.planRepository.findOne({
      where: { id: planId },
    });
    if (!plan) {
      throw new NotFoundException(
        buildHttpExceptionResponse(HttpStatus.NOT_FOUND, [
          'Kế hoạch không tồn tại',
        ]),
      );
    }

    const planItem = await this.planItemRepository.findOneByIdAndPlan(
      planItemId,
      planId,
    );
    if (!planItem) {
      throw new NotFoundException(
        buildHttpExceptionResponse(HttpStatus.NOT_FOUND, [
          'Mục chi tiêu không tồn tại trong kế hoạch',
        ]),
      );
    }

    await this.defaultTransactionAutoGenerator.removeAutoGeneratedTransactions(
      planItemId,
      dto.date,
    );

    const transactionType =
      planItem.type === PlanItemType.INCOME
        ? TransactionType.INCOME
        : TransactionType.EXPENSE;

    const dailyTransaction = this.dailyTransactionRepository.create({
      label: dto.label,
      amount: dto.amount,
      date: dto.date,
      type: transactionType,
      planId: plan.id,
      plan: plan,
      planItemId: planItem.id,
      planItem: planItem,
      categoryId: planItem.categoryId,
      isDefaultGenerated: false,
    });

    const saved = await this.dailyTransactionRepository.save(dailyTransaction);

    // Chỉ áp dụng minimumPercentage cho chi tiêu (EXPENSE) loại FLEXIBLE
    if (
      planItem.excludeType === EXCLUDE_TYPE.FLEXIBLE &&
      planItem.type === PlanItemType.EXPENSE &&
      planItem.minimumPercentage
    ) {
      await this.handleFlexibleItemCalculation(
        plan,
        planItem,
        saved.date,
        parseFloat(saved.amount),
      );
    }

    await this.updateDailySummary(
      plan.id,
      saved.date,
      saved.type,
      saved.amount,
    );

    return new DailyTransactionResponseDto({
      id: saved.id,
      planId: saved.planId,
      planItemId: saved.planItemId,
      date: saved.date,
      label: saved.label,
      amount: saved.amount,
      createdAt: saved.createdAt,
    });
  }

  private async handleFlexibleItemCalculation(
    plan: any,
    planItem: any,
    date: string,
    transactionAmount: number,
  ): Promise<void> {
    const dailyAverage = this.planCalculationService.calculateDailyAverage(
      parseFloat(planItem.amount.toString()),
      plan.planType,
      date,
    );

    const dailyMinimum = this.planCalculationService.calculateDailyMinimum(
      dailyAverage,
      planItem.minimumPercentage || 0,
    );

    const dailySummary =
      await this.dailySummaryRepository.findOrCreateByPlanAndDate(
        plan.id,
        date,
      );

    const exceedsAverage = transactionAmount > dailyAverage;

    let newAverage = dailyAverage;
    if (exceedsAverage) {
      const transactionDate = new Date(date);
      const periodStart = this.getPeriodStartDate(
        plan.planType,
        transactionDate,
      );
      const daysPassed =
        Math.floor(
          (transactionDate.getTime() - periodStart.getTime()) /
            (1000 * 60 * 60 * 24),
        ) + 1;

      newAverage = this.planCalculationService.recalculateAverageAfterExceed(
        parseFloat(planItem.amount.toString()),
        plan.planType,
        transactionDate,
        transactionAmount,
        daysPassed,
      );
    }

    const isBelowMinimum = this.planCalculationService.isBelowMinimum(
      transactionAmount,
      dailyMinimum,
    );

    dailySummary.flexibleAverageAmount = newAverage.toString();
    dailySummary.flexibleMinimumThreshold = dailyMinimum.toString();
    dailySummary.isBelowMinimum = isBelowMinimum;

    if (isBelowMinimum) {
      dailySummary.status = DailyStatus.WARNING;
    } else if (exceedsAverage) {
      dailySummary.status = DailyStatus.EXCEED;
    } else {
      dailySummary.status = DailyStatus.OK;
    }

    await this.dailySummaryRepository.save(dailySummary);
  }

  private getPeriodStartDate(planType: string, date: Date): Date {
    const d = new Date(date);
    switch (planType) {
      case 'DAILY':
        return new Date(d.setHours(0, 0, 0, 0));
      case 'WEEKLY':
        const day = d.getDay();
        const diff = d.getDate() - day + (day === 0 ? -6 : 1);
        return new Date(d.setDate(diff));
      case 'MONTHLY':
        return new Date(d.getFullYear(), d.getMonth(), 1);
      case 'YEARLY':
        return new Date(d.getFullYear(), 0, 1);
      default:
        return new Date(d.setHours(0, 0, 0, 0));
    }
  }

  private async updateDailySummary(
    planId: string,
    date: string,
    type: string,
    amount: string,
  ): Promise<void> {
    const summary = await this.dailySummaryRepository.findOrCreateByPlanAndDate(
      planId,
      date,
    );

    const amountNum = parseFloat(amount);

    if (type === 'income') {
      const current = parseFloat(summary.totalActualIncome || '0');
      summary.totalActualIncome = (current + amountNum).toString();
    } else {
      const current = parseFloat(summary.totalActualExpense || '0');
      summary.totalActualExpense = (current + amountNum).toString();
    }

    await this.dailySummaryRepository.save(summary);
  }
}
